from collections import deque

# Represent state as a tuple of 9 elements
# Example: (1,2,3,4,5,6,7,8,0)
goal_state = (1,2,3,4,5,6,7,8,0)

# Define legal moves of the blank (0)
moves = {
    0: [1,3],
    1: [0,2,4],
    2: [1,5],
    3: [0,4,6],
    4: [1,3,5,7],
    5: [2,4,8],
    6: [3,7],
    7: [4,6,8],
    8: [5,7]
}

def get_neighbors(state):
    """Return all possible moves from current state."""
    zero_pos = state.index(0)
    neighbors = []
    for move in moves[zero_pos]:
        new_state = list(state)
        new_state[zero_pos], new_state[move] = new_state[move], new_state[zero_pos]
        neighbors.append(tuple(new_state))
    return neighbors
def bfs(start):
    queue = deque([start])
    visited = {start: None}  # parent map

    while queue:
        state = queue.popleft()
        if state == goal_state:
            return reconstruct_path(visited, state)
        for neighbor in get_neighbors(state):
            if neighbor not in visited:
                visited[neighbor] = state
                queue.append(neighbor)
    return None

def reconstruct_path(visited, end):
    path = []
    while end:
        path.append(end)
        end = visited[end]
    return path[::-1]
def dfs(start, visited=None, depth=0, max_depth=20):
    if visited is None:
        visited = set()
    visited.add(start)

    if start == goal_state:
        return [start]
    if depth == max_depth:
        return None

    for neighbor in get_neighbors(start):
        if neighbor not in visited:
            path = dfs(neighbor, visited, depth+1, max_depth)
            if path:
                return [start] + path
    return None
def ids(start, max_depth=30):
    for depth in range(max_depth):
        visited = set()
        path = dls(start, visited, 0, depth)
        if path:
            return path
    return None

def dls(state, visited, depth, limit):
    visited.add(state)
    if state == goal_state:
        return [state]
    if depth == limit:
        return None

    for neighbor in get_neighbors(state):
        if neighbor not in visited:
            path = dls(neighbor, visited, depth+1, limit)
            if path:
                return [state] + path
    return None

(b) Why DFS is not suitable for the 8-puzzle

There are three main reasons:

Huge Search Space

The 8-puzzle has 9! = 362,880 possible states, and only half are solvable.
DFS may go extremely deep into unpromising branches before finding a valid solution.

No Backtracking Limit

DFS explores one branch completely before trying another.
In 8-puzzle, moves can easily cycle (e.g., swapping tiles back and forth),
so without careful cycle checking, DFS may get stuck or loop forever.

Non-Optimal Solution

Even if DFS finds a solution, it is not guaranteed to be the shortest.
BFS and IDS, by contrast, find minimal-move solutions.
